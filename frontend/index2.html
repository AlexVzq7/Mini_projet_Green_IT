<!DOCTYPE html>
<html lang="fr">
   <head>
      <meta charset="UTF-8" />
      <title>Jeu de Dames - Animation Fluide Corrigée</title>
      <style>
         body {
            font-family: sans-serif;
            text-align: center;
         }
         /* Conteneur pour permettre le positionnement absolu du pion animé */
         #board-container {
            position: relative;
            display: inline-block;
         }
         #board {
            margin: 20px auto;
            border-collapse: collapse;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.469);
         }
         #board td {
            width: 60px;
            height: 60px;
            text-align: center;
            vertical-align: middle;
            font-size: 36px;
            cursor: pointer;
            position: relative;
         }
         .light {
            background-color: #eee;
         }
         .dark {
            background-color: #555;
            color: white;
         }
         .piece {
            display: inline-block;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            line-height: 60px;
            text-align: center;
            font-weight: bold;
         }
         .white-piece {
            background-color: #fff;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.724);
         }
         .black-piece {
            background-color: #000;
            color: #000;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.724);
         }
         .dame {
            box-shadow: 0 0 0 3px gold inset;
         }
         .selected {
            outline: 3px solid yellow;
         }
         .highlight {
            background-color: #88cc88 !important;
         }
      </style>
   </head>
   <body>
      <h1>Jeu de Dames</h1>
      <div id="status" style="font-weight: bold; font-size: 20px; margin: 15px 0 50px 0"></div>
      <div style="margin: 20px 0">
         <div
            id="white-player"
            style="font-weight: bold; font-size: 18px; margin-bottom: 10px"
         ></div>
      </div>

      <div id="board-container">
         <table id="board"></table>
         <div id="black-player" style="font-weight: bold; font-size: 18px; margin-top: 30px"></div>
      </div>

      <script>
         // Représentation du plateau :
         //  0 = case vide
         //  1 = pion blanc, 2 = dame blanche
         // -1 = pion noir, -2 = dame noire
         const SIZE = 10;
         let board = [];
         let currentPlayer = 1; // 1 pour BLANCS, -1 pour NOIRS
         let selected = null; // {r, c} de la pièce sélectionnée
         let forcedMoves = null;
         let gameEnded = false;
         const whitePlayerName = localStorage.getItem("user_1")
            ? JSON.parse(localStorage.getItem("user_1")).username
            : "Blanc";
         const blackPlayerName = localStorage.getItem("user_2")
            ? JSON.parse(localStorage.getItem("user_2")).username
            : "Noir";

         function initBoard() {
            board = [];
            for (let r = 0; r < SIZE; r++) {
               board[r] = [];
               for (let c = 0; c < SIZE; c++) {
                  board[r][c] = 0;
               }
            }
            // Placement des pions blancs (4 rangées du bas)
            for (let r = 0; r < 4; r++) {
               for (let c = 0; c < SIZE; c++) {
                  if ((r + c) % 2 === 0) {
                     board[r][c] = 1;
                  }
               }
            }
            // Placement des pions noirs (4 rangées du haut)
            for (let r = SIZE - 4; r < SIZE; r++) {
               for (let c = 0; c < SIZE; c++) {
                  if ((r + c) % 2 === 0) {
                     board[r][c] = -1;
                  }
               }
            }
         }

         function renderBoard() {
            const table = document.getElementById("board");
            table.innerHTML = "";
            for (let r = SIZE - 1; r >= 0; r--) {
               const row = document.createElement("tr");
               for (let c = 0; c < SIZE; c++) {
                  const cell = document.createElement("td");
                  cell.className = (r + c) % 2 === 0 ? "dark" : "light";
                  cell.dataset.r = r;
                  cell.dataset.c = c;
                  cell.addEventListener("click", onCellClick);
                  let piece = board[r][c];
                  if (piece !== 0) {
                     const pieceDiv = document.createElement("div");
                     pieceDiv.classList.add("piece");
                     if (Math.abs(piece) === 1) {
                        if (piece === 1) {
                           pieceDiv.classList.add("white-piece");
                           pieceDiv.textContent = "●";
                        } else {
                           pieceDiv.classList.add("black-piece");
                           pieceDiv.textContent = "●";
                        }
                     } else {
                        if (piece === 2) {
                           pieceDiv.classList.add("white-piece", "dame");
                           pieceDiv.textContent = "♔";
                        } else {
                           pieceDiv.classList.add("black-piece", "dame");
                           pieceDiv.textContent = "♚";
                        }
                     }
                     cell.appendChild(pieceDiv);
                  }
                  row.appendChild(cell);
               }
               table.appendChild(row);
               document.getElementById("white-player").textContent =
                  "Joueur BLANC : " + whitePlayerName;
               document.getElementById("black-player").textContent =
                  "Joueur NOIR : " + blackPlayerName;
            }
            document.getElementById("status").textContent = gameEnded
               ? "Fin de la partie"
               : currentPlayer === 1
               ? "Au tour des BLANCS"
               : "Au tour des NOIRS";
         }

         function inBounds(r, c) {
            return r >= 0 && r < SIZE && c >= 0 && c < SIZE;
         }

         function getAllForcedMoves(player) {
            let moves = [];
            for (let r = 0; r < SIZE; r++) {
               for (let c = 0; c < SIZE; c++) {
                  if (board[r][c] * player > 0) {
                     let caps = getCaptures(r, c, board, board[r][c]);
                     if (caps.length > 0) {
                        moves.push({ from: { r, c }, moves: caps });
                     }
                  }
               }
            }
            let maxCapt = 0;
            moves.forEach((item) => {
               item.moves.forEach((seq) => {
                  if (seq.captures.length > maxCapt) maxCapt = seq.captures.length;
               });
            });
            moves.forEach((item) => {
               item.moves = item.moves.filter((seq) => seq.captures.length === maxCapt);
            });
            moves = moves.filter((item) => item.moves.length > 0);
            return moves;
         }

         function cloneBoard(b) {
            return b.map((row) => row.slice());
         }

         const directions = [
            { dr: 1, dc: 1 },
            { dr: 1, dc: -1 },
            { dr: -1, dc: 1 },
            { dr: -1, dc: -1 },
         ];

         function getSimpleMoves(r, c, board, piece) {
            let moves = [];
            let dirs = [];
            if (Math.abs(piece) === 1) {
               let forward = piece === 1 ? 1 : -1;
               dirs = [
                  { dr: forward, dc: 1 },
                  { dr: forward, dc: -1 },
               ];
            } else {
               dirs = directions;
            }
            for (let d of dirs) {
               if (Math.abs(piece) === 1) {
                  let nr = r + d.dr,
                     nc = c + d.dc;
                  if (inBounds(nr, nc) && board[nr][nc] === 0) {
                     moves.push({ path: [{ r: nr, c: nc }], captures: [] });
                  }
               } else {
                  let nr = r + d.dr,
                     nc = c + d.dc;
                  while (inBounds(nr, nc) && board[nr][nc] === 0) {
                     moves.push({ path: [{ r: nr, c: nc }], captures: [] });
                     nr += d.dr;
                     nc += d.dc;
                  }
               }
            }
            return moves;
         }

         function getCaptures(r, c, boardState, piece, capturedAlready = []) {
            let moves = [];
            let dirs;
            if (Math.abs(piece) === 1 && capturedAlready.length === 0) {
               let forward = piece === 1 ? 1 : -1;
               dirs = [
                  { dr: forward, dc: 1 },
                  { dr: forward, dc: -1 },
               ];
            } else {
               dirs = directions;
            }
            for (let d of dirs) {
               if (Math.abs(piece) === 1) {
                  let midR = r + d.dr,
                     midC = c + d.dc;
                  let endR = r + 2 * d.dr,
                     endC = c + 2 * d.dc;
                  if (
                     inBounds(endR, endC) &&
                     boardState[midR][midC] * piece < 0 &&
                     boardState[endR][endC] === 0
                  ) {
                     if (!capturedAlready.some((pos) => pos.r === midR && pos.c === midC)) {
                        let newBoard = cloneBoard(boardState);
                        newBoard[r][c] = 0;
                        newBoard[midR][midC] = 0;
                        newBoard[endR][endC] = piece;
                        if (Math.abs(piece) === 1) {
                           if ((piece === 1 && endR === SIZE - 1) || (piece === -1 && endR === 0)) {
                              newBoard[endR][endC] = piece > 0 ? 2 : -2;
                           }
                        }
                        let newCaptured = capturedAlready.concat([{ r: midR, c: midC }]);
                        let further = getCaptures(
                           endR,
                           endC,
                           newBoard,
                           newBoard[endR][endC],
                           newCaptured
                        );
                        if (further.length > 0) {
                           for (let seq of further) {
                              moves.push({
                                 path: [{ r: endR, c: endC }].concat(seq.path),
                                 captures: [{ r: midR, c: midC }].concat(seq.captures),
                              });
                           }
                        } else {
                           moves.push({
                              path: [{ r: endR, c: endC }],
                              captures: [{ r: midR, c: midC }],
                           });
                        }
                     }
                  }
               } else {
                  let nr = r + d.dr,
                     nc = c + d.dc;
                  while (inBounds(nr, nc) && boardState[nr][nc] === 0) {
                     nr += d.dr;
                     nc += d.dc;
                  }
                  if (inBounds(nr, nc) && boardState[nr][nc] * piece < 0) {
                     let jumpR = nr + d.dr,
                        jumpC = nc + d.dc;
                     while (inBounds(jumpR, jumpC) && boardState[jumpR][jumpC] === 0) {
                        if (!capturedAlready.some((pos) => pos.r === nr && pos.c === nc)) {
                           let newBoard = cloneBoard(boardState);
                           newBoard[r][c] = 0;
                           newBoard[nr][nc] = 0;
                           newBoard[jumpR][jumpC] = piece;
                           let newCaptured = capturedAlready.concat([{ r: nr, c: nc }]);
                           let further = getCaptures(jumpR, jumpC, newBoard, piece, newCaptured);
                           if (further.length > 0) {
                              for (let seq of further) {
                                 moves.push({
                                    path: [{ r: jumpR, c: jumpC }].concat(seq.path),
                                    captures: [{ r: nr, c: nc }].concat(seq.captures),
                                 });
                              }
                           } else {
                              moves.push({
                                 path: [{ r: jumpR, c: jumpC }],
                                 captures: [{ r: nr, c: nc }],
                              });
                           }
                        }
                        jumpR += d.dr;
                        jumpC += d.dc;
                     }
                  }
               }
            }
            return moves;
         }

         function getMovesForPiece(r, c) {
            let piece = board[r][c];
            let moves = getCaptures(r, c, board, piece);
            if (moves.length === 0) {
               moves = getSimpleMoves(r, c, board, piece);
            }
            return moves;
         }

         function checkGameOver() {
            let whiteCount = 0,
               blackCount = 0;
            for (let r = 0; r < SIZE; r++) {
               for (let c = 0; c < SIZE; c++) {
                  if (board[r][c] > 0) whiteCount++;
                  if (board[r][c] < 0) blackCount++;
               }
            }
            if (whiteCount === 0 || blackCount === 0) {
               gameEnded = true;
               let winner = whiteCount === 0 ? "NOIRS" : "BLANCS";
               updateStatus("Fin de la partie : " + winner + " ont gagné !");
               return true;
            }
            let hasMove = false;
            for (let r = 0; r < SIZE; r++) {
               for (let c = 0; c < SIZE; c++) {
                  if (board[r][c] * currentPlayer > 0) {
                     if (getMovesForPiece(r, c).length > 0) {
                        hasMove = true;
                        break;
                     }
                  }
               }
               if (hasMove) break;
            }
            if (!hasMove) {
               gameEnded = true;
               let winner = currentPlayer === 1 ? "NOIRS" : "BLANCS";
               updateStatus("Fin de la partie : " + winner + " ont gagné !");
               return true;
            }
            return false;
         }

         // Animation fluide par translation d'une case à l'autre,
         // avec suppression progressive des pions capturés.
         function animateMove(fromR, fromC, path, piece, captures, callback) {
            const container = document.getElementById("board-container");
            // Création d'un élément temporaire pour l'animation
            const tempPiece = document.createElement("div");
            tempPiece.classList.add("piece");
            if (Math.abs(piece) === 1) {
               if (piece === 1) {
                  tempPiece.classList.add("white-piece");
                  tempPiece.textContent = "●";
               } else {
                  tempPiece.classList.add("black-piece");
                  tempPiece.textContent = "●";
               }
            } else {
               if (piece === 2) {
                  tempPiece.classList.add("white-piece", "dame");
                  tempPiece.textContent = "♔";
               } else {
                  tempPiece.classList.add("black-piece", "dame");
                  tempPiece.textContent = "♚";
               }
            }
            tempPiece.style.position = "absolute";
            tempPiece.style.transition = "left 0.3s ease, top 0.3s ease";
            tempPiece.style.zIndex = "1000";

            // Fixer la taille du pion animé pour qu'il corresponde à l'affichage
            const sampleCell = document.querySelector("#board td");
            if (sampleCell) {
               const cellWidth = sampleCell.offsetWidth;
               const pieceSize = cellWidth * 0.8;
               tempPiece.style.width = pieceSize + "px";
               tempPiece.style.height = pieceSize + "px";
               tempPiece.style.lineHeight = pieceSize + "px";
               tempPiece.style.fontSize = "36px";
            }

            // Fonction pour obtenir la position absolue d'une case par rapport au conteneur
            function getCellPosition(r, c) {
               const cell = document.querySelector(`#board td[data-r='${r}'][data-c='${c}']`);
               const containerRect = container.getBoundingClientRect();
               const cellRect = cell.getBoundingClientRect();
               return {
                  left: cellRect.left - containerRect.left,
                  top: cellRect.top - containerRect.top,
               };
            }

            // Position de départ
            const startPos = getCellPosition(fromR, fromC);
            tempPiece.style.left = startPos.left + "px";
            tempPiece.style.top = startPos.top + "px";
            container.appendChild(tempPiece);

            // On retire la pièce du plateau pour éviter un doublon visuel
            board[fromR][fromC] = 0;
            renderBoard();

            // Construction du chemin complet (incluant la position de départ)
            let steps = [{ r: fromR, c: fromC }].concat(path);
            let stepIndex = 0;

            function animateNextStep() {
               if (stepIndex >= steps.length - 1) {
                  // Fin de l'animation : mise à jour finale du plateau
                  const finalPos = steps[steps.length - 1];
                  board[finalPos.r][finalPos.c] = piece;
                  container.removeChild(tempPiece);
                  renderBoard();
                  if (callback) callback();
                  return;
               }
               stepIndex++;
               // Si une capture doit intervenir à cette étape, la supprimer du plateau et de l'affichage
               if (stepIndex - 1 < captures.length) {
                  let cap = captures[stepIndex - 1];
                  if (cap) {
                     board[cap.r][cap.c] = 0;
                     let capCell = document.querySelector(
                        `#board td[data-r='${cap.r}'][data-c='${cap.c}']`
                     );
                     if (capCell) {
                        capCell.innerHTML = "";
                     }
                  }
               }
               const nextPos = steps[stepIndex];
               const pos = getCellPosition(nextPos.r, nextPos.c);
               tempPiece.style.left = pos.left + "px";
               tempPiece.style.top = pos.top + "px";
               tempPiece.addEventListener("transitionend", onTransitionEnd);
            }

            function onTransitionEnd(e) {
               tempPiece.removeEventListener("transitionend", onTransitionEnd);
               animateNextStep();
            }

            animateNextStep();
         }

         function onCellClick(e) {
            if (gameEnded) return;
            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);
            if (selected && e.currentTarget.classList.contains("highlight")) {
               let possible = getMovesForPiece(selected.r, selected.c);
               let chosen = possible.find((mv) => mv.path[0].r === r && mv.path[0].c === c);
               if (!chosen) return;
               let piece = board[selected.r][selected.c];
               animateMove(
                  selected.r,
                  selected.c,
                  chosen.path,
                  piece,
                  chosen.captures,
                  function () {
                     let finalPos = chosen.path[chosen.path.length - 1];
                     if (Math.abs(piece) === 1) {
                        if (
                           (piece === 1 && finalPos.r === SIZE - 1) ||
                           (piece === -1 && finalPos.r === 0)
                        ) {
                           board[finalPos.r][finalPos.c] = piece === 1 ? 2 : -2;
                        }
                     }
                     renderBoard();
                     let newPiece = board[finalPos.r][finalPos.c];
                     let further = getCaptures(finalPos.r, finalPos.c, board, newPiece);
                     if (chosen.captures.length > 0 && further.length > 0) {
                        selected = { r: finalPos.r, c: finalPos.c };
                        clearHighlights();
                        highlightCell(selected.r, selected.c);
                        further.forEach((mv) => highlightCell(mv.path[0].r, mv.path[0].c));
                        updateStatus("Multi-capture obligatoire avec la même pièce");
                        return;
                     }
                     if (checkGameOver()) return;
                     currentPlayer *= -1;
                     clearHighlights();
                     selected = null;
                     updateStatus(currentPlayer === 1 ? "Au tour des BLANCS" : "Au tour des NOIRS");
                  }
               );
               return;
            }
            if (board[r][c] * currentPlayer > 0) {
               forcedMoves = getAllForcedMoves(currentPlayer);
               if (
                  forcedMoves.length > 0 &&
                  !forcedMoves.some((item) => item.from.r === r && item.from.c === c)
               ) {
                  updateStatus("Vous devez effectuer une prise obligatoire !");
                  return;
               }
               selected = { r, c };
               clearHighlights();
               highlightCell(r, c);
               let moves = getMovesForPiece(r, c);
               if (forcedMoves && forcedMoves.length > 0) {
                  moves = moves.filter((mv) => mv.captures.length > 0);
               }
               moves.forEach((mv) => highlightCell(mv.path[0].r, mv.path[0].c));
            }
         }

         function highlightCell(r, c) {
            const cells = document.querySelectorAll("#board td");
            cells.forEach((cell) => {
               if (parseInt(cell.dataset.r) === r && parseInt(cell.dataset.c) === c) {
                  cell.classList.add("highlight");
               }
            });
         }

         function clearHighlights() {
            const cells = document.querySelectorAll("#board td");
            cells.forEach((cell) => cell.classList.remove("highlight"));
         }

         function updateStatus(msg) {
            document.getElementById("status").textContent = msg;
         }

         initBoard();
         renderBoard();
      </script>
   </body>
</html>
